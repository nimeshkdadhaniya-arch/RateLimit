@startuml
title Rate Limiter - Class Diagram

package "com.example.ratelimit" {
  class "Filter.RateLimitFilter" {
    - ASYNC_TIMEOUT_MS : long
    + doFilterInternal(req : HttpServletRequest, res : HttpServletResponse, chain : FilterChain) : void
  }

  interface "api.IRateLimitService" {
    + setHeaders(req : HttpServletRequest, res : HttpServletResponse, limiter : RateLimiter) : void
    + tryAcquire(req : HttpServletRequest, res : HttpServletResponse) : boolean
  }
  interface "api.RateLimiter" {
    + getRateLimitHeaderInfo(req : HttpServletRequest) : header.RateLimitHeaderInfo
  }
  interface "api.GlobalRateLimiter" {
    + tryAcquire() : boolean
  }
  interface "api.KeyRateLimiter" {
    + tryAcquire(key : String) : boolean
  }

  class "service.RateLimitService" {
    + setHeaders(req : HttpServletRequest, res : HttpServletResponse, limiter : RateLimiter) : void
    + tryAcquire(req : HttpServletRequest, res : HttpServletResponse) : boolean
  }

  class "service.RateLimitFilterFactoryConfig" {
    ~ bucketCapacity : long
    ~ max_requests_per_window : int
    + filterBasedOnType(t : helper.RateLimiterTypeEnum) : GlobalRateLimiter
    + filterBasedOnKey(t : helper.RateLimiterTypeEnum) : Optional
  }

  class "service.BoundedRetryQueueService" {
    - queue : ArrayBlockingQueue
    - retryIntervalMs : long
    + enqueue(d : helper.DroppedRequest) : boolean
    + startWorker() : void
  }

  class "controller.RateLimitController" {
    + checkLimit() : ResponseEntity
  }

  class "helper.DroppedRequest" {
    ~ asyncContext : AsyncContext
    ~ filterChain : FilterChain
    - request : HttpServletRequest
    - response : HttpServletResponse
    - attempts : int
    + incrementAttempts() : void
  }

  enum "helper.RateLimiterTypeEnum" {
    FIXED_WINDOW
    SLIDING_WINDOW_LOG
    SLIDING_WINDOW_LOG_USER
    TOKEN_BUCKET
  }

  class "helper.TokenBucketConfig" {
    - bucket_capacity : long
    - refillIntervalMillis : long
    - refillTokens : long
  }

  class "impl.FixedWindowRateLimit" {
    - MAX_REQUESTS_PER_WINDOW : int
    - WINDOW_SIZE_MS : long
    + tryAcquire() : boolean
    + getRemainingLimit() : long
  }

  class "impl.SlidingWindowLogRateLimit" {
    - MAX_REQUESTS_PER_WINDOW : int
    - WINDOW_SIZE_MS : long
    + tryAcquire() : boolean
    + getRemainingLimit() : long
  }

  class "impl.SlidingWindowLogUserRateLimit" {
    - MAX_REQUESTS_PER_WINDOW : int
    - WINDOW_SIZE_MS : long
    - userRequestLogs : ConcurrentHashMap
    + tryAcquire(userKey : String) : boolean
    + getRemainingLimit(userKey : String) : long
  }

  class "impl.TokenBucketRateLimit" {
    - availableTokens : AtomicLong
    - bucket_capacity : long
    - lastRefillTimestamp : AtomicLong
    - refillIntervalMillis : long
    + tryAcquire() : boolean
    + refill() : void
  }

  class "header.RateLimitHeaderInfo" {
    + limit : long
    + remaining : long
    + reset : long
  }
}

' relationships
Filter.RateLimitFilter --> IRateLimitService : rateLimitService
Filter.RateLimitFilter --> service.BoundedRetryQueueService : retryQueueService

service.RateLimitService ..|> api.IRateLimitService
service.RateLimitService --> service.RateLimitFilterFactoryConfig : rateLimitFactoryConfig

api.GlobalRateLimiter ..|> api.RateLimiter
api.KeyRateLimiter ..|> api.RateLimiter

impl.FixedWindowRateLimit ..|> api.GlobalRateLimiter
impl.SlidingWindowLogRateLimit ..|> api.GlobalRateLimiter
impl.SlidingWindowLogUserRateLimit ..|> api.KeyRateLimiter
impl.TokenBucketRateLimit ..|> api.GlobalRateLimiter

service.BoundedRetryQueueService --> service.RateLimitFilterFactoryConfig : factoryConfig
service.BoundedRetryQueueService --> service.RateLimitService : rateLimitService
service.RateLimitFilterFactoryConfig ..> api.RateLimiter : returns
helper.DroppedRequest --> Filter.RateLimitFilter : usedBy

@enduml
